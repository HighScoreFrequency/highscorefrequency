<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>High Score Voice Activation</title>
  <link href="https://fonts.googleapis.com/css2?family=Unbounded:wght@500&display=swap" rel="stylesheet" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #f3f6f9;
      font-family: 'Unbounded', cursive;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: visible;
      scroll-behavior: smooth;
    }

    .portal-wrapper {
      position: relative;
      width: 93vmin;
      height: 93vmin;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Waveform behind everything */
    canvas#waveform {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      background: transparent;
      pointer-events: none;
    }

    /* Golden rings */
    .ring {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      background: transparent;
      box-sizing: content-box;
    }
    .ring1 {
      width: 96vmin; height: 90vmin; border-radius: 50%;
      border: 4px solid #a9712c;
      animation: rotateCounter 69s linear infinite;
      z-index: 1;
      mask-image: radial-gradient(circle, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
    }
    .ring2 {
      width: 90vmin; height: 84vmin; border-radius: 50%;
      border: 2px solid #ffcc33;
      animation: rotateCounter 111s linear infinite;
      z-index: 1;
      mask-image: radial-gradient(circle, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
    }
    .ring3 {
      width: 90vmin; height: 84vmin; border-radius: 50%;
      border: 2px solid #a9712c;
      animation: rotateClockwise 69s linear infinite;
      z-index: 1;
      mask-image: radial-gradient(circle, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
    }
    .ring4 {
      width: 96vmin; height: 90vmin; border-radius: 50%;
      border: 4px solid #ffd700;
      animation: rotateClockwise 111s linear infinite;
      z-index: 1;
      mask-image: radial-gradient(circle, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
    }

    @keyframes rotateClockwise {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to   { transform: translate(-50%, -50%) rotate(360deg); }
    }
    @keyframes rotateCounter {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to   { transform: translate(-50%, -50%) rotate(-360deg); }
    }

    .content {
      position: relative;
      z-index: 2;
      width: 85%;
      max-width: 360px;
      padding: 15px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.35);
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .fade-layer {
      position: absolute; inset: 0;
      border-radius: 12px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.96), rgba(255,255,255,0.96));
      opacity: 0;
      z-index: 1;
      transition: opacity 0.25s ease;
      pointer-events: none;
      backdrop-filter: blur(2px);
    }
    .content > *:not(.fade-layer) { position: relative; z-index: 2; }

    h2 { font-size: 20px; margin: 6px 0 10px; }

    p { font-size: 14px; color: #444; margin: 10px 0 16px; }

    .input-wrapper { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 6px; }

    .declaration-wrapper {
      width: 100%;
      padding: 2px; border-radius: 6px;
      background: linear-gradient(135deg, #ffcc33, #a9712c, #ffd700);
    }
    #declaration-box {
      width: 100%; min-height: 60px; max-height: 150px;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 12px; line-height: 1.25;
      color: #222; background: rgba(255,255,255,0.95);
      overflow-y: auto; border: 0;
      display: flex; align-items: center; justify-content: center;
      text-align: left;
      font-family: 'Unbounded', cursive;
    }
    #declaration-text { white-space: pre-line; }

    select {
      width: 100%; padding: 8px; font-size: 12px;
      border-radius: 6px; border: 0; box-sizing: border-box;
      background: #fff;
    }

    .button-group { width: 100%; display: flex; flex-direction: column; gap: 8px; margin-top: 6px; }
    .row { display: flex; gap: 8px; width: 100%; justify-content: space-between; }
    button {
      background: #1a1a1a; color: #fff; border: 0;
      padding: 6px 16px; font-size: 12px; border-radius: 6px;
      cursor: pointer; transition: transform .18s ease, box-shadow .18s ease, opacity .18s ease;
    }
    button:hover:not(:disabled) { transform: scale(0.96); box-shadow: 0 0 6px rgba(0,0,0,.15); }
    button:disabled { background: #666; cursor: not-allowed; opacity: .75; }

    audio { width: 100%; max-width: 300px; margin-top: 10px; }
    a { display: inline-block; margin-top: 12px; text-decoration: none; color: #007bff; font-size: 14px; }

    @media (max-width: 768px) {
      .ring1, .ring4 { width: 440px !important; height: 420px !important; }
      .ring2, .ring3 { width: 420px !important; height: 400px !important; }
      .portal-wrapper { width: 100vw !important; height: 100vh !important; }
      .content { width: 85% !important; max-width: 360px !important; padding: 15px !important; background: rgba(255,255,255,.28) !important; }
      h2 { font-size: 17px !important; }
      p { font-size: 14px !important; }
      button { font-size: 12px !important; padding: 6px 16px !important; }
    }
  </style>
</head>
<body>
  <div class="portal-wrapper">
    <canvas id="waveform"></canvas>
    <div class="ring ring1" id="ring1"></div>
    <div class="ring ring2" id="ring2"></div>
    <div class="ring ring3" id="ring3"></div>
    <div class="ring ring4" id="ring4"></div>

    <div class="content">
      <div class="fade-layer"></div>

      <h2>
        <span style="font-size:12px;">(</span><span style="font-size:16px;">(</span><span style="font-size:20px;">(</span>
        <strong>High Score Voice Portal</strong>
        <span style="font-size:20px;">)</span><span style="font-size:16px;">)</span><span style="font-size:12px;">)</span>
      </h2>

      <div class="input-wrapper">
        <div class="declaration-wrapper" style="width:100%;">
          <div id="declaration-box"><div id="declaration-text"></div></div>
        </div>

        <select id="promptSelect">
          <option value="">‚ú® Choose Your Crystalline Activation</option>
          <option value="1">‚ö°Ô∏è Unlock My Final Form</option>
          <option value="2">üî• Clear Limited Codes</option>
          <option value="3">üöÄ Load the Expansion Pack</option>
          <option value="4">üíé Equip Divine Union Mode</option>
          <option value="5">üëë Highest Most Prosporous Self</option>
        </select>

        <select id="frequencySelect">
          <option value="528">528 Hz ‚Äì üß¨ Cell Recalibration ‚Äì Level Up to Wholeness</option>
          <option value="639">639 Hz ‚Äì üíñ Heart Link Gateway ‚Äì Sync Into Unity Field</option>
          <option value="963">963 Hz ‚Äì üëë Crown Signal ‚Äì Access Divine Intelligence</option>
          <option value="0">0 Hz ‚Äì üïäÔ∏è Silence Mode ‚Äì Record Without Tone</option>
        </select>

        <div class="button-group">
          <div class="row">
            <button id="preview-btn">üîä Preview Tone</button>
            <button id="record-btn">üü¢ Start Recording</button>
          </div>
          <div class="row">
            <button id="stopBtn" disabled>üõë Stop</button>
            <button id="resetBtn" disabled>üîÅ Reset</button>
          </div>
        </div>

        <audio id="audioPlayback" controls style="display:none;"></audio>
        <a id="downloadLink" style="display:none;">‚¨áÔ∏è Download Your Recording</a>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas setup (DPR-aware) =====
  const canvas = document.getElementById('waveform');
  const ctx = canvas.getContext('2d');
  const rings = [document.getElementById('ring1'), document.getElementById('ring2'), document.getElementById('ring3'), document.getElementById('ring4')];
  const fadeLayer = document.querySelector('.fade-layer');

  function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const { clientWidth, clientHeight } = canvas;
    canvas.width = Math.round(clientWidth * dpr);
    canvas.height = Math.round(clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  const ro = new ResizeObserver(resizeCanvas);
  ro.observe(canvas);

  // ===== Audio graph =====
  const AudioContextRef = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContextRef({ latencyHint: 'interactive' });

  // Nodes (created as needed)
  let analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  const timeData = new Uint8Array(analyser.fftSize);

  // Recorder plumbing
  let mediaRecorder = null;
  let mixedStream = null;
  let recordChunks = [];

  // Tone nodes
  let oscillator = null;
  let gainNode = null;
  let panner = null;
  let previewPlaying = false;

  // UI
  const recordBtn  = document.getElementById('record-btn');
  const stopBtn    = document.getElementById('stopBtn');
  const resetBtn   = document.getElementById('resetBtn');
  const previewBtn = document.getElementById('preview-btn');
  const audioPlayback = document.getElementById('audioPlayback');
  const downloadLink  = document.getElementById('downloadLink');
  const frequencySelect = document.getElementById('frequencySelect');

  // Declaration copy
  const promptSelect = document.getElementById('promptSelect');
  const declarationText = document.getElementById('declaration-text');
  const declarations = {
    "": `Choose your tone, speak it clear,
code your vibe, draw truth near.
This isn‚Äôt sound, it‚Äôs memory‚Äôs key,
a voice-led path to mastery.`,
    "1": `‚ö°Ô∏è Unlock My Final Form

I now unlock my final form‚Äî
... (trimmed for brevity in this block)
I now unlock my final form.`,
    "2": `üî• Clear Limited Codes

I speak these words to clear the way,
...`,
    "3": `üöÄ Load the Expansion Pack

I now unlock what‚Äôs always mine‚Äî
...`,
    "4": `üëë Equip Divine Union Mode

I call in love that mirrors true‚Äî
...`
  };
  function updateDeclaration(){ declarationText.textContent = declarations[promptSelect.value] || declarations[""]; }
  updateDeclaration();
  promptSelect.addEventListener('change', updateDeclaration);

  // ===== Utility: create tone with ADSR and stopWithFade =====
  function createTone(freq, attack=1.5, sustain=0.02, release=1.5) {
    oscillator = audioCtx.createOscillator();
    gainNode   = audioCtx.createGain();
    panner     = audioCtx.createStereoPanner();

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

    const now = audioCtx.currentTime;
    gainNode.gain.cancelScheduledValues(now);
    gainNode.gain.setValueAtTime(0, now);
    gainNode.gain.linearRampToValueAtTime(sustain, now + attack);

    oscillator.connect(panner).connect(gainNode);
    // stopWithFade returns a Promise that resolves after the stop time
    oscillator.stopWithFade = (rel=release) => new Promise(resolve => {
      const t0 = audioCtx.currentTime;
      const stopTime = t0 + Math.max(0.01, rel);
      gainNode.gain.cancelScheduledValues(t0);
      // preserve current level then ramp to 0
      const current = gainNode.gain.value;
      gainNode.gain.setValueAtTime(current, t0);
      gainNode.gain.linearRampToValueAtTime(0, stopTime);
      oscillator.stop(stopTime);
      setTimeout(resolve, (stopTime - t0) * 1000 + 20);
    });

    return gainNode;
  }

  // ===== Visualizer loop (reacts to mic when recording; idle shimmer otherwise) =====
  let prevOpacity = 0.99;
  let idlePhase = 0;
  function draw() {
    requestAnimationFrame(draw);
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const midY = h/2;

    let active = false;
    if (analyser && analyser.numberOfInputs !== 0) {
      try { analyser.getByteTimeDomainData(timeData); active = true; } catch(e){}
    }

    ctx.beginPath();
    ctx.lineWidth = 2.5;
    const grad = ctx.createLinearGradient(0,0,w,0);
    grad.addColorStop(0, '#5a9fe6');
    grad.addColorStop(1, '#5aecc6');
    ctx.strokeStyle = grad;

    const len = timeData.length;
    const slice = w / len;

    let ampSum = 0;

    if (active && timeData[0] !== 0) {
      // mic-reactive curve
      let x = 0;
      for (let i=0;i<len;i++){
        const v = (timeData[i]-128)/128; // -1..1
        const y = midY + v * (h*0.35);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        x += slice;
        ampSum += Math.abs(v);
      }
    } else {
      // idle slow sine shimmer
      idlePhase += 0.015;
      let x = 0;
      for (let i=0;i<len;i++){
        const v = Math.sin((i/len)*Math.PI*4 + idlePhase) * 0.15;
        const y = midY + v * (h*0.35);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        x += slice;
        ampSum += Math.abs(v);
      }
    }
    ctx.stroke();

    // Fade layer + ring glow follow amplitude
    const avg = ampSum / len; // ~0..1
    const targetOpacity = Math.max(0.02, 0.99 - Math.min(1, avg*2)*0.99);
    const smoothed = prevOpacity + (targetOpacity - prevOpacity)*0.12;
    prevOpacity = smoothed;
    fadeLayer.style.opacity = smoothed.toFixed(2);

    const glow = Math.min(1, avg*3);
    const glowA = 0.25 + glow*0.5;
    const glowB = 0.15 + glow*0.4;
    const glowC = 0.08 + glow*0.25;
    rings.forEach(r=>{
      r.style.boxShadow =
        `0 0 20px rgba(255,215,0,${glowA}), 0 0 40px rgba(255,215,0,${glowB}), 0 0 70px rgba(255,215,0,${glowC})`;
    });
  }
  draw();

  // ===== Button State Helpers =====
  function setPreviewDisabled(disabled) {
    previewBtn.disabled = disabled;
    previewBtn.textContent = disabled ? 'üîá Preview Disabled' : 'üîä Preview Tone';
  }
  function setPreviewStopUI() { previewBtn.textContent = 'üõë Stop Preview'; }
  function ensurePreviewOffUI() { previewBtn.textContent = 'üîä Preview Tone'; previewPlaying = false; }

  // ===== Preview Tone =====
  async function stopPreviewTone(instant=false) {
    if (!oscillator) return;
    try {
      if (!instant && oscillator.stopWithFade) {
        await oscillator.stopWithFade(1.5);
      } else {
        oscillator.stop();
      }
    } catch(_){}
    oscillator = null; gainNode = null; panner = null;
    ensurePreviewOffUI();
  }

  previewBtn.addEventListener('click', async () => {
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    const freq = parseFloat(frequencySelect.value);
    if (freq === 0) return;

    if (!previewPlaying) {
      const node = createTone(freq, 1.5, 0.02, 1.5);
      node.connect(audioCtx.destination);
      oscillator.start();
      previewPlaying = true;
      setPreviewStopUI();
    } else {
      await stopPreviewTone(false);
    }
  });

  // Disable/enable preview when selecting Silence
  frequencySelect.addEventListener('change', async () => {
    const freq = parseFloat(frequencySelect.value);
    if (freq === 0) {
      await stopPreviewTone(true);
      setPreviewDisabled(true);
    } else {
      setPreviewDisabled(false);
      ensurePreviewOffUI();
    }
  });
  // initial state
  setPreviewDisabled(parseFloat(frequencySelect.value) === 0);

  // ===== Recording =====
  function pickMime() {
    if (MediaRecorder.isTypeSupported('audio/mp3'))  return { mime:'audio/mp3',  ext:'mp3' };
    if (MediaRecorder.isTypeSupported('audio/mpeg')) return { mime:'audio/mpeg', ext:'mp3' };
    if (MediaRecorder.isTypeSupported('audio/webm')) return { mime:'audio/webm', ext:'webm' };
    return { mime:'', ext:'webm' };
  }

  async function startRecording() {
    const freq = parseFloat(frequencySelect.value);
    const toneNode = freq > 0 ? createTone(freq, 1.5, 0.02, 1.5) : null;

    try {
      const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const micSource = audioCtx.createMediaStreamSource(micStream);
      micSource.connect(analyser);

      const dest = audioCtx.createMediaStreamDestination();
      micSource.connect(dest);
      if (toneNode) toneNode.connect(dest);

      mixedStream = dest.stream;

      const { mime, ext } = pickMime();
      mediaRecorder = mime ? new MediaRecorder(mixedStream, { mimeType: mime }) : new MediaRecorder(mixedStream);

      recordChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recordChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordChunks, { type: mediaRecorder.mimeType || mime || 'audio/webm' });
        const url = URL.createObjectURL(blob);
        audioPlayback.src = url;
        audioPlayback.style.display = 'block';
        const date = new Date().toISOString().split('T')[0];
        downloadLink.href = url;
        downloadLink.download = `highscore-frequency-${date}.${ext}`;
        downloadLink.style.display = 'inline-block';
      };

      mediaRecorder.start();
      if (toneNode) oscillator.start();

      // UI states
      recordBtn.disabled = true;
      stopBtn.disabled   = false;
      setPreviewDisabled(true);

    } catch (err) {
      alert('Microphone access denied or unavailable.');
      // restore UI
      recordBtn.disabled = false;
      stopBtn.disabled   = true;
      setPreviewDisabled(parseFloat(frequencySelect.value) === 0);
    }
  }

  recordBtn.addEventListener('click', async () => {
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    // If preview is playing, stop it first (with fade), then record
    if (previewPlaying) {
      await stopPreviewTone(false);
      setTimeout(startRecording, 1550); // allow fade tail
    } else {
      startRecording();
    }
  });

  // Stop with guaranteed tail capture: fade tone, wait 1.5s, then stop recorder.
  stopBtn.addEventListener('click', async () => {
    stopBtn.disabled = true;

    // Trigger fade if tone exists
    if (oscillator && oscillator.stopWithFade) {
      await oscillator.stopWithFade(1.5);
    }
    oscillator = null; gainNode = null; panner = null;

    // Wait a touch to guarantee tail captured (safety cushion)
    setTimeout(() => {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }, 50); // tiny cushion (fade already awaited)

    // Re-enable UI
    recordBtn.disabled = false;
    resetBtn.disabled  = false;

    // Restore preview button (unless Silence mode)
    const freq = parseFloat(frequencySelect.value);
    setPreviewDisabled(freq === 0);
    ensurePreviewOffUI();
  });

  resetBtn.addEventListener('click', () => {
    audioPlayback.pause();
    audioPlayback.currentTime = 0;
    audioPlayback.src = '';
    audioPlayback.style.display = 'none';
    downloadLink.href = '';
    downloadLink.download = '';
    downloadLink.style.display = 'none';
    resetBtn.disabled = true;
  });
})();
</script>
</body>
</html>
